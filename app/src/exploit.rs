use clap::Parser;
use clio::OutputPath;
use anyhow::{bail, Context, Ok, Result};
use chains_evm_core::{
    db::{BlockchainDbMeta, ChainSpec, JsonBlockCacheDB}, evm_primitives::{Address, Bloom, ToAlloy, U256},
    input_builder::build_vminput, poc_compiler::compile_poc, provider::try_get_http_provider
};
use bridge::{ BlockHeader, VmOutput};
use ethers_core::types::BlockNumber;
use ethers_providers::Middleware;
use guests::{EXPLOIT_ID, EXPLOIT_ELF};
use risc0_zkvm::sha::Digest;
use crate::{proof::Proof, prover::{execute, prove}};


#[derive(Parser, Debug)]
pub struct ExploitArgs {
    poc: String,

    #[clap(short, long)]
    rpc_url: String,

    #[clap(short, long)]
    block_number: Option<u64>,

    /// Generate a zkp through Bonsai, should set BONSAI_API_URL and BONSAI_API_KEY environment variables
    #[clap(short, long, default_value_t = false)]
    pub prove: bool,

    /// Output file 
    #[clap(long, short, value_parser, default_value = "odesec_proof.zkp")]
    output: OutputPath,
}

impl ExploitArgs {
    pub async fn run(self) -> Result<()> {
        println!("ImageId: {}", Digest::from(EXPLOIT_ID));
        let poc_runtime_bytecode = compile_poc(self.poc)?;
        let provider = try_get_http_provider(self.rpc_url)?;
        let block_id = match self.block_number {
            Some(n) => BlockNumber::from(n),
            None => BlockNumber::Safe,
        };
        let block = provider.get_block(block_id).await?;
        let chain_id = provider.get_chainid().await?;
        let block = block.expect("cound not found block");
        println!("Block Number: {}", block.number.unwrap());

        let header = BlockHeader {
            parent_hash: block.parent_hash.to_alloy(),
            uncles_hash: block.uncles_hash.to_alloy(),
            author: block.author.context("author missing")?.to_alloy(),
            state_root: block.state_root.to_alloy(),
            transactions_root: block.transactions_root.to_alloy(),
            receipts_root: block.receipts_root.to_alloy(),
            logs_bloom: Bloom::from_slice(
                block.logs_bloom.context("logs_bloom missing")?.as_bytes()
            ),
            difficulty: block.difficulty.to_alloy(),
            number: block.number.context("block number missing")?.as_u64(),
            gas_limit: block.gas_limit.to_alloy(),
            gas_used: block.gas_used.to_alloy(),
            timestamp: block.timestamp.to_alloy(),
            extra_data: block.extra_data.0.into(),
            mix_hash: block.mix_hash.context("mix_hash missing")?.to_alloy(),
            nonce: block.nonce.context("nonce missing")?.0.into(),
            base_fee_per_gas: block.base_fee_per_gas.context("base_fee_per_gas missing")?.to_alloy(),
            withdrawals_root: block.withdrawals_root.map(|x| x.to_alloy()),
            blob_gas_used: block.blob_gas_used.map(|x| x.to_alloy()),
            excess_blob_gas: block.excess_blob_gas.map(|x| x.to_alloy()),
            parent_beacon_block_root: block.parent_beacon_block_root.map(|x| x.to_alloy()),
        };
        
        if header.hash() != block.hash.unwrap().to_alloy() {
            bail!("block header build failed")
        }

        let meta = BlockchainDbMeta {
            chain_spec: ChainSpec::mainnet(),
            header: header.clone(),
        };

        let rpc_cache_dir = dirs_next::home_dir().expect("home dir not found").join(".0xhacked").join("cache").join("rpc");
        let cache_path =  rpc_cache_dir.join(format!("{}", meta.chain_spec.chain_id)).join(format!("{}.json", header.number));
        let db = JsonBlockCacheDB::new(&provider, meta, Some(cache_path));
        
        let author = Address::default().0;
        let vm_input = build_vminput(poc_runtime_bytecode, header,  &db, U256::ZERO, *author)?;
        db.flush();
        
        let journal = execute(&vm_input, 20, false, EXPLOIT_ELF, None);
        let buf = &mut journal.bytes.as_slice();
        let vm_output = VmOutput::decode(buf);
        print_vmoutput_pretty(&vm_output);

        if self.prove {
            let (_, stark_receipt) = prove(&vm_input, EXPLOIT_ELF, true, Default::default())?;
            let proof = Proof {
                version: env!("CARGO_PKG_VERSION").to_string(),
                image_id: EXPLOIT_ID,
                receipt: stark_receipt,
                chain: chain_id.to_string(),
            };
            let mut output = self.output.create()?;
            proof.save(&mut output)?;
        }
        
        Ok(())
    }
}

fn print_vmoutput_pretty(vm_output: &VmOutput) {
    println!("VmOutput: ");
    println!("Artifacts Hash: {:#x}", vm_output.artifacts_hash);
    println!("Block Hashes: ");
    for (number, hash) in vm_output.block_hashes.iter() {
        println!(" {}: {:#x}", number, hash);
    }
    println!("Poc Contract Hash: {:#x}", vm_output.poc_contract_hash);
    println!("Author: {:#x}", Address::from(vm_output.author));
    println!("Accounts: ");
    for (address, state_diff) in vm_output.state_diff.iter() {
        println!(" Address: {:#x}", address);
        if let Some(balance) = &state_diff.balance {
            println!("  Balance: {} -> {}", balance.old, balance.new);
        }
        println!("  Storage:");
        for (key, value) in state_diff.storage.iter() {
            println!("   slot: {:#x} {:#x} -> {:#x}", key, value.old, value.new);
        }
    }
}