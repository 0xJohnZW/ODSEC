{
  "language": "Solidity",
  "sources": {
    "contracts/ODESEC.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n// Useful for debugging. Remove when deploying to a live network.\r\n// import \"hardhat/console.sol\";\r\n\r\nimport {IRiscZeroVerifier} from \"risc0/IRiscZeroVerifier.sol\";\r\nimport {Strings} from \"openzeppelin/contracts/utils/Strings.sol\";\r\n\r\ncontract ODESEC {\r\n    IRiscZeroVerifier public verifier;\r\n    /// @notice Image ID of the only zkVM binary to accept verification from.\r\n    bytes32 public imageId;\r\n    // State Variables\r\n    address public immutable owner;\r\n    uint256 public totalProjects;\r\n    bytes public constant MAGIC = \"ODSEC\";\r\n\r\n    event ProjectAdded(uint256 projectId, string domain, address owner);\r\n\r\n    struct ProjectData {\r\n        address owner;\r\n        address[] contracts;\r\n        string domain;\r\n        string contact;\r\n    }\r\n\r\n    mapping(uint256 => ProjectData) public projects;\r\n    mapping(bytes32 => uint256) public projectIds;\r\n\r\n    // Constructor: Called once on contract deployment\r\n    // Check packages/hardhat/deploy/00_deploy_your_contract.ts\r\n    constructor(address _owner, IRiscZeroVerifier _verifier, bytes32 _imageId) {\r\n        owner = _owner;\r\n        verifier = _verifier;\r\n        imageId = _imageId;\r\n    }\r\n\r\n    modifier isOwner() {\r\n        // msg.sender: predefined variable that represents address of the account that called the current function\r\n        require(msg.sender == owner, \"Not the Owner\");\r\n        _;\r\n    }\r\n\r\n    function updateImageId(bytes32 _imageId) public isOwner {\r\n        imageId = _imageId;\r\n    }\r\n\r\n    function addProject(\r\n        string memory _domain,\r\n        string memory _contact,\r\n        address[] memory _contracts,\r\n        address _owner,\r\n        bytes memory receipt\r\n    ) public {\r\n        (bytes memory journal, bytes32 postStateDigest, bytes memory seal) =\r\n            abi.decode(receipt, (bytes, bytes32, bytes));\r\n\r\n        require(_owner != address(0), \"Invalid owner\");\r\n        require(bytes(_domain).length > 3, \"Invalid domain\");\r\n        require(projectIdOfDomain(_domain) == 0, \"Project already exists\");\r\n        require(verifier.verify(seal, imageId, postStateDigest, sha256(journal)));\r\n\r\n        bytes20 challenge = makeChallenge(_domain, _owner);\r\n        string memory challengeDomain = string.concat(challengeToHex(challenge), \".\", _domain);\r\n        require(Strings.equal(challengeDomain, string(journal)), \"Invalid Challenge\");\r\n        totalProjects += 1;\r\n        uint256 projectId = totalProjects;\r\n        projects[projectId] = ProjectData(_owner, _contracts, _domain, _contact);\r\n        projectIds[keccak256(bytes(_domain))] = projectId;\r\n        emit ProjectAdded(projectId, _domain, _owner);\r\n    }\r\n\r\n    /**\r\n     * get the projectId by domain, if the domain is not registered, return 0\r\n     */\r\n    function projectIdOfDomain(string memory _domain) public view returns (uint256) {\r\n        return projectIds[keccak256(bytes(_domain))];\r\n    }\r\n\r\n    function updateProject(uint256 projectId, string memory contact, address[] memory contracts) public {\r\n        ProjectData storage project = projects[projectId];\r\n        require(msg.sender == project.owner, \"Only owner can update project\");\r\n        project.contact = contact;\r\n        project.contracts = contracts;\r\n    }\r\n\r\n    function getProjectList(uint256 limit, uint256 offset) public view returns (ProjectData[] memory) {\r\n        uint256 count = limit > totalProjects - offset ? totalProjects - offset : limit;\r\n        ProjectData[] memory _projects = new ProjectData[](count);\r\n        offset += 1;\r\n        for (uint256 i = 0; i < count; i++) {\r\n            _projects[i] = projects[offset + i];\r\n        }\r\n        return _projects;\r\n    }\r\n\r\n    function makeChallenge(string memory domain, address _owner) public pure returns (bytes20) {\r\n        return bytes20(keccak256(abi.encodePacked(MAGIC, domain, _owner)));\r\n    }\r\n\r\n    function challengeToHex(bytes20 data) internal pure returns (string memory) {\r\n        bytes memory alphabet = \"0123456789abcdef\";\r\n\r\n        bytes memory str = new bytes(40);\r\n        for (uint256 i = 0; i < 20; i++) {\r\n            str[i * 2] = alphabet[uint8(data[i] >> 4)];\r\n            str[i * 2 + 1] = alphabet[uint8(data[i] & 0x0f)];\r\n        }\r\n        return string(str);\r\n    }\r\n}\r\n"
    },
    "openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Muldiv operation overflow.\r\n     */\r\n    error MathOverflowedMulDiv();\r\n\r\n    enum Rounding {\r\n        Floor, // Toward negative infinity\r\n        Ceil, // Toward positive infinity\r\n        Trunc, // Toward zero\r\n        Expand // Away from zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds towards infinity instead\r\n     * of rounding towards zero.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (b == 0) {\r\n            // Guarantee the same behavior as in a regular Solidity division.\r\n            return a / b;\r\n        }\r\n\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\r\n     * denominator == 0.\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\r\n     * Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            if (denominator <= prod1) {\r\n                revert MathOverflowedMulDiv();\r\n            }\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\r\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            uint256 twos = denominator & (0 - denominator);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\r\n            // works in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\r\n     * towards zero.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\r\n     */\r\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\r\n        return uint8(rounding) % 2 == 1;\r\n    }\r\n}\r\n"
    },
    "openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n    /**\r\n     * @dev Returns the largest of two signed numbers.\r\n     */\r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two signed numbers.\r\n     */\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two signed numbers without overflow.\r\n     * The result is rounded towards zero.\r\n     */\r\n    function average(int256 a, int256 b) internal pure returns (int256) {\r\n        // Formula from the book \"Hacker's Delight\"\r\n        int256 x = (a & b) + ((a ^ b) >> 1);\r\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the absolute unsigned value of a signed value.\r\n     */\r\n    function abs(int256 n) internal pure returns (uint256) {\r\n        unchecked {\r\n            // must be unchecked in order to support `n = type(int256).min`\r\n            return uint256(n >= 0 ? n : -n);\r\n        }\r\n    }\r\n}\r\n"
    },
    "openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.20;\r\n\r\nimport {Math} from \"./math/Math.sol\";\r\nimport {SignedMath} from \"./math/SignedMath.sol\";\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\r\n    uint8 private constant ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev The `value` string doesn't fit in the specified `length`.\r\n     */\r\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toStringSigned(int256 value) internal pure returns (string memory) {\r\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        uint256 localValue = value;\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\r\n            localValue >>= 4;\r\n        }\r\n        if (localValue != 0) {\r\n            revert StringsInsufficientHexLength(value, length);\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\r\n     * representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two strings are equal.\r\n     */\r\n    function equal(string memory a, string memory b) internal pure returns (bool) {\r\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}\r\n"
    },
    "risc0/IRiscZeroVerifier.sol": {
      "content": "// Copyright 2024 RISC Zero, Inc.\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//     http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n//\r\n// SPDX-License-Identifier: Apache-2.0\r\n\r\npragma solidity ^0.8.9;\r\n\r\n/// @notice Public claims about a zkVM guest execution, such as the journal committed to by the guest.\r\n/// @dev Also includes important information such as the exit code and the starting and ending system\r\n/// state (i.e. the state of memory). `ReceiptClaim` is a \"Merkle-ized struct\" supporting\r\n/// partial openings of the underlying fields from a hash commitment to the full structure.\r\nstruct ReceiptClaim {\r\n    /// @notice Digest of the SystemState just before execution has begun.\r\n    bytes32 preStateDigest;\r\n    /// @notice Digest of the SystemState just after execution has completed.\r\n    bytes32 postStateDigest;\r\n    /// @notice The exit code for the execution.\r\n    ExitCode exitCode;\r\n    /// @notice A digest of the input to the guest.\r\n    /// @dev This field is currently unused and must be set to the zero digest.\r\n    bytes32 input;\r\n    /// @notice Digest of the Output of the guest, including the journal\r\n    /// and assumptions set during execution.\r\n    bytes32 output;\r\n}\r\n\r\nlibrary ReceiptClaimLib {\r\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.ReceiptClaim\");\r\n\r\n    function digest(ReceiptClaim memory claim) internal pure returns (bytes32) {\r\n        return sha256(\r\n            abi.encodePacked(\r\n                TAG_DIGEST,\r\n                // down\r\n                claim.input,\r\n                claim.preStateDigest,\r\n                claim.postStateDigest,\r\n                claim.output,\r\n                // data\r\n                uint32(claim.exitCode.system) << 24,\r\n                uint32(claim.exitCode.user) << 24,\r\n                // down.length\r\n                uint16(4) << 8\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\n/// @notice Exit condition indicated by the zkVM at the end of the guest execution.\r\n/// @dev Exit codes have a \"system\" part and a \"user\" part. Semantically, the system part is set to\r\n/// indicate the type of exit (e.g. halt, pause, or system split) and is directly controlled by the\r\n/// zkVM. The user part is an exit code, similar to exit codes used in Linux, chosen by the guest\r\n/// program to indicate additional information (e.g. 0 to indicate success or 1 to indicate an\r\n/// error).\r\nstruct ExitCode {\r\n    SystemExitCode system;\r\n    uint8 user;\r\n}\r\n\r\n/// @notice Exit condition indicated by the zkVM at the end of the execution covered by this proof.\r\n/// @dev\r\n/// `Halted` indicates normal termination of a program with an interior exit code returned from the\r\n/// guest program. A halted program cannot be resumed.\r\n///\r\n/// `Paused` indicates the execution ended in a paused state with an interior exit code set by the\r\n/// guest program. A paused program can be resumed such that execution picks up where it left\r\n/// of, with the same memory state.\r\n///\r\n/// `SystemSplit` indicates the execution ended on a host-initiated system split. System split is\r\n/// mechanism by which the host can temporarily stop execution of the execution ended in a system\r\n/// split has no output and no conclusions can be drawn about whether the program will eventually\r\n/// halt. System split is used in continuations to split execution into individually provable segments.\r\nenum SystemExitCode {\r\n    Halted,\r\n    Paused,\r\n    SystemSplit\r\n}\r\n\r\n/// @notice Output field in the `ReceiptClaim`, committing to a claimed journal and assumptions list.\r\nstruct Output {\r\n    /// @notice Digest of the journal committed to by the guest execution.\r\n    bytes32 journalDigest;\r\n    /// @notice Digest of the ordered list of `ReceiptClaim` digests corresponding to the\r\n    /// calls to `env::verify` and `env::verify_integrity`.\r\n    /// @dev Verifying the integrity of a `Receipt` corresponding to a `ReceiptClaim` with a\r\n    /// non-empty assumptions list does not guarantee unconditionally any of the claims over the\r\n    /// guest execution (i.e. if the assumptions list is non-empty, then the journal digest cannot\r\n    /// be trusted to correspond to a genuine execution). The claims can be checked by additional\r\n    /// verifying a `Receipt` for every digest in the assumptions list.\r\n    bytes32 assumptionsDigest;\r\n}\r\n\r\nlibrary OutputLib {\r\n    bytes32 constant TAG_DIGEST = sha256(\"risc0.Output\");\r\n\r\n    function digest(Output memory output) internal pure returns (bytes32) {\r\n        return sha256(\r\n            abi.encodePacked(\r\n                TAG_DIGEST,\r\n                // down\r\n                output.journalDigest,\r\n                output.assumptionsDigest,\r\n                // down.length\r\n                uint16(2) << 8\r\n            )\r\n        );\r\n    }\r\n}\r\n\r\n/// @notice A receipt attesting to the execution of a guest program.\r\n/// @dev A receipt contains two parts: a seal and a claim. The seal is a zero-knowledge proof\r\n/// attesting to knowledge of a zkVM execution resulting in the claim. The claim is a set of public\r\n/// outputs for the execution. Crucially, the claim includes the journal and the image ID. The\r\n/// image ID identifies the program that was executed, and the journal is the public data written\r\n/// by the program.\r\nstruct Receipt {\r\n    bytes seal;\r\n    ReceiptClaim claim;\r\n}\r\n\r\n/// @notice Verifier interface for RISC Zero receipts of execution.\r\ninterface IRiscZeroVerifier {\r\n    /// @notice Verify that the given seal is a valid RISC Zero proof of execution with the\r\n    ///     given image ID, post-state digest, and journal digest.\r\n    /// @dev This method additionally ensures that the input hash is all-zeros (i.e. no\r\n    /// committed input), the exit code is (Halted, 0), and there are no assumptions (i.e. the\r\n    /// receipt is unconditional).\r\n    /// @param seal The encoded cryptographic proof (i.e. SNARK).\r\n    /// @param imageId The identifier for the guest program.\r\n    /// @param postStateDigest A hash of the final memory state. Required to run the verifier, but\r\n    ///     otherwise can be left unconstrained for most use cases.\r\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\r\n    /// @return true if the receipt passes the verification checks. The return code must be checked.\r\n    function verify(bytes calldata seal, bytes32 imageId, bytes32 postStateDigest, bytes32 journalDigest)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    /// @notice Verify that the given receipt is a valid RISC Zero receipt, ensuring the `seal` is\r\n    /// valid a cryptographic proof of the execution with the given `claim`.\r\n    /// @param receipt The receipt to be verified.\r\n    /// @return true if the receipt passes the verification checks. The return code must be checked.\r\n    function verify_integrity(Receipt calldata receipt) external view returns (bool);\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}