{
  "address": "0x5A5A08A118E11A4FE56D5c7cc752aAb7d45330f5",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "CONTROL_ID_0",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CONTROL_ID_1",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "seal",
          "type": "bytes"
        },
        {
          "internalType": "bytes32",
          "name": "imageId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "postStateDigest",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "journalDigest",
          "type": "bytes32"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[2]",
          "name": "_pA",
          "type": "uint256[2]"
        },
        {
          "internalType": "uint256[2][2]",
          "name": "_pB",
          "type": "uint256[2][2]"
        },
        {
          "internalType": "uint256[2]",
          "name": "_pC",
          "type": "uint256[2]"
        },
        {
          "internalType": "uint256[4]",
          "name": "_pubSignals",
          "type": "uint256[4]"
        }
      ],
      "name": "verifyProof",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "seal",
              "type": "bytes"
            },
            {
              "components": [
                {
                  "internalType": "bytes32",
                  "name": "preStateDigest",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "postStateDigest",
                  "type": "bytes32"
                },
                {
                  "components": [
                    {
                      "internalType": "enum SystemExitCode",
                      "name": "system",
                      "type": "uint8"
                    },
                    {
                      "internalType": "uint8",
                      "name": "user",
                      "type": "uint8"
                    }
                  ],
                  "internalType": "struct ExitCode",
                  "name": "exitCode",
                  "type": "tuple"
                },
                {
                  "internalType": "bytes32",
                  "name": "input",
                  "type": "bytes32"
                },
                {
                  "internalType": "bytes32",
                  "name": "output",
                  "type": "bytes32"
                }
              ],
              "internalType": "struct ReceiptClaim",
              "name": "claim",
              "type": "tuple"
            }
          ],
          "internalType": "struct Receipt",
          "name": "receipt",
          "type": "tuple"
        }
      ],
      "name": "verify_integrity",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x0e725c01da538ee3a0a36866064a6732135177b53a35367e512198d7cd762c9b",
  "receipt": {
    "to": null,
    "from": "0x7fDf85917BAf7E5c3f06AdF59506eD3E4201c43B",
    "contractAddress": "0x5A5A08A118E11A4FE56D5c7cc752aAb7d45330f5",
    "transactionIndex": 61,
    "gasUsed": "1009914",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xcdb33052cf1959f114eb56aba1cb22eea64f9713c83ecfce54c0ee5be9674d01",
    "transactionHash": "0x0e725c01da538ee3a0a36866064a6732135177b53a35367e512198d7cd762c9b",
    "logs": [],
    "blockNumber": 5725277,
    "cumulativeGasUsed": "9862723",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "7ba06b2fe933858123412f6421e68663",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CONTROL_ID_0\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONTROL_ID_1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"seal\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"imageId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"postStateDigest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"journalDigest\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2]\",\"name\":\"_pA\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[2][2]\",\"name\":\"_pB\",\"type\":\"uint256[2][2]\"},{\"internalType\":\"uint256[2]\",\"name\":\"_pC\",\"type\":\"uint256[2]\"},{\"internalType\":\"uint256[4]\",\"name\":\"_pubSignals\",\"type\":\"uint256[4]\"}],\"name\":\"verifyProof\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"seal\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"preStateDigest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"postStateDigest\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"enum SystemExitCode\",\"name\":\"system\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"user\",\"type\":\"uint8\"}],\"internalType\":\"struct ExitCode\",\"name\":\"exitCode\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"input\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"output\",\"type\":\"bytes32\"}],\"internalType\":\"struct ReceiptClaim\",\"name\":\"claim\",\"type\":\"tuple\"}],\"internalType\":\"struct Receipt\",\"name\":\"receipt\",\"type\":\"tuple\"}],\"name\":\"verify_integrity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"verify(bytes,bytes32,bytes32,bytes32)\":{\"details\":\"This method additionally ensures that the input hash is all-zeros (i.e. no committed input), the exit code is (Halted, 0), and there are no assumptions (i.e. the receipt is unconditional).\",\"params\":{\"imageId\":\"The identifier for the guest program.\",\"journalDigest\":\"The SHA-256 digest of the journal bytes.\",\"postStateDigest\":\"A hash of the final memory state. Required to run the verifier, but     otherwise can be left unconstrained for most use cases.\",\"seal\":\"The encoded cryptographic proof (i.e. SNARK).\"},\"returns\":{\"_0\":\"true if the receipt passes the verification checks. The return code must be checked.\"}},\"verify_integrity((bytes,(bytes32,bytes32,(uint8,uint8),bytes32,bytes32)))\":{\"params\":{\"receipt\":\"The receipt to be verified.\"},\"returns\":{\"_0\":\"true if the receipt passes the verification checks. The return code must be checked.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"CONTROL_ID_0()\":{\"notice\":\"Control ID hash for the identity_p254 predicate decomposed by `splitDigest`.\"},\"verify(bytes,bytes32,bytes32,bytes32)\":{\"notice\":\"Verify that the given seal is a valid RISC Zero proof of execution with the     given image ID, post-state digest, and journal digest.\"},\"verify_integrity((bytes,(bytes32,bytes32,(uint8,uint8),bytes32,bytes32)))\":{\"notice\":\"Verify that the given receipt is a valid RISC Zero receipt, ensuring the `seal` is valid a cryptographic proof of the execution with the given `claim`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/SimpleVerifier.sol\":\"SimpleVerifier\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/SimpleVerifier.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport {ControlID, RiscZeroGroth16Verifier} from \\\"risc0/groth16/RiscZeroGroth16Verifier.sol\\\";\\r\\n\\r\\ncontract SimpleVerifier is RiscZeroGroth16Verifier {\\r\\n    constructor() RiscZeroGroth16Verifier(ControlID.CONTROL_ID_0, ControlID.CONTROL_ID_1) {}\\r\\n}\\r\\n\",\"keccak256\":\"0x3830bb322151b7266cdab2697a1ce77caf6c00f87d42046c5413cd138e1360da\",\"license\":\"MIT\"},\"openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SafeCast.sol)\\r\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\r\\n\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\r\\n * checks.\\r\\n *\\r\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\r\\n * easily result in undesired exploitation or bugs, since developers usually\\r\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\r\\n * reverting the transaction when such an operation overflows.\\r\\n *\\r\\n * Using this library instead of the unchecked operations eliminates an entire\\r\\n * class of bugs, so it's recommended to use it always.\\r\\n */\\r\\nlibrary SafeCast {\\r\\n    /**\\r\\n     * @dev Value doesn't fit in an uint of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev An int value doesn't fit in an uint of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedIntToUint(int256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Value doesn't fit in an int of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev An uint value doesn't fit in an int of `bits` size.\\r\\n     */\\r\\n    error SafeCastOverflowedUintToInt(uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     */\\r\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\r\\n        if (value > type(uint248).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(248, value);\\r\\n        }\\r\\n        return uint248(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     */\\r\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\r\\n        if (value > type(uint240).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(240, value);\\r\\n        }\\r\\n        return uint240(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     */\\r\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\r\\n        if (value > type(uint232).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(232, value);\\r\\n        }\\r\\n        return uint232(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     */\\r\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\r\\n        if (value > type(uint224).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(224, value);\\r\\n        }\\r\\n        return uint224(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     */\\r\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\r\\n        if (value > type(uint216).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(216, value);\\r\\n        }\\r\\n        return uint216(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     */\\r\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\r\\n        if (value > type(uint208).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(208, value);\\r\\n        }\\r\\n        return uint208(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     */\\r\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\r\\n        if (value > type(uint200).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(200, value);\\r\\n        }\\r\\n        return uint200(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     */\\r\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\r\\n        if (value > type(uint192).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(192, value);\\r\\n        }\\r\\n        return uint192(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     */\\r\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\r\\n        if (value > type(uint184).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(184, value);\\r\\n        }\\r\\n        return uint184(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     */\\r\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\r\\n        if (value > type(uint176).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(176, value);\\r\\n        }\\r\\n        return uint176(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     */\\r\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\r\\n        if (value > type(uint168).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(168, value);\\r\\n        }\\r\\n        return uint168(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     */\\r\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\r\\n        if (value > type(uint160).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(160, value);\\r\\n        }\\r\\n        return uint160(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     */\\r\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\r\\n        if (value > type(uint152).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(152, value);\\r\\n        }\\r\\n        return uint152(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     */\\r\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\r\\n        if (value > type(uint144).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(144, value);\\r\\n        }\\r\\n        return uint144(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     */\\r\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\r\\n        if (value > type(uint136).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(136, value);\\r\\n        }\\r\\n        return uint136(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     */\\r\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\r\\n        if (value > type(uint128).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(128, value);\\r\\n        }\\r\\n        return uint128(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     */\\r\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\r\\n        if (value > type(uint120).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(120, value);\\r\\n        }\\r\\n        return uint120(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     */\\r\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\r\\n        if (value > type(uint112).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(112, value);\\r\\n        }\\r\\n        return uint112(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     */\\r\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\r\\n        if (value > type(uint104).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(104, value);\\r\\n        }\\r\\n        return uint104(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     */\\r\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\r\\n        if (value > type(uint96).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(96, value);\\r\\n        }\\r\\n        return uint96(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     */\\r\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\r\\n        if (value > type(uint88).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(88, value);\\r\\n        }\\r\\n        return uint88(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     */\\r\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\r\\n        if (value > type(uint80).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(80, value);\\r\\n        }\\r\\n        return uint80(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     */\\r\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\r\\n        if (value > type(uint72).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(72, value);\\r\\n        }\\r\\n        return uint72(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     */\\r\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\r\\n        if (value > type(uint64).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(64, value);\\r\\n        }\\r\\n        return uint64(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     */\\r\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\r\\n        if (value > type(uint56).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(56, value);\\r\\n        }\\r\\n        return uint56(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     */\\r\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\r\\n        if (value > type(uint48).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(48, value);\\r\\n        }\\r\\n        return uint48(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     */\\r\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\r\\n        if (value > type(uint40).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(40, value);\\r\\n        }\\r\\n        return uint40(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     */\\r\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\r\\n        if (value > type(uint32).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(32, value);\\r\\n        }\\r\\n        return uint32(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     */\\r\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\r\\n        if (value > type(uint24).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(24, value);\\r\\n        }\\r\\n        return uint24(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     */\\r\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\r\\n        if (value > type(uint16).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(16, value);\\r\\n        }\\r\\n        return uint16(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\r\\n     * overflow (when the input is greater than largest uint8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `uint8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     */\\r\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\r\\n        if (value > type(uint8).max) {\\r\\n            revert SafeCastOverflowedUintDowncast(8, value);\\r\\n        }\\r\\n        return uint8(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a signed int256 into an unsigned uint256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be greater than or equal to 0.\\r\\n     */\\r\\n    function toUint256(int256 value) internal pure returns (uint256) {\\r\\n        if (value < 0) {\\r\\n            revert SafeCastOverflowedIntToUint(value);\\r\\n        }\\r\\n        return uint256(value);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int248 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int248 or\\r\\n     * greater than largest int248).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int248` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 248 bits\\r\\n     */\\r\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\r\\n        downcasted = int248(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(248, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int240 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int240 or\\r\\n     * greater than largest int240).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int240` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 240 bits\\r\\n     */\\r\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\r\\n        downcasted = int240(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(240, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int232 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int232 or\\r\\n     * greater than largest int232).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int232` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 232 bits\\r\\n     */\\r\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\r\\n        downcasted = int232(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(232, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int224 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int224 or\\r\\n     * greater than largest int224).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int224` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 224 bits\\r\\n     */\\r\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\r\\n        downcasted = int224(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(224, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int216 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int216 or\\r\\n     * greater than largest int216).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int216` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 216 bits\\r\\n     */\\r\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\r\\n        downcasted = int216(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(216, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int208 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int208 or\\r\\n     * greater than largest int208).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int208` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 208 bits\\r\\n     */\\r\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\r\\n        downcasted = int208(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(208, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int200 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int200 or\\r\\n     * greater than largest int200).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int200` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 200 bits\\r\\n     */\\r\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\r\\n        downcasted = int200(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(200, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int192 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int192 or\\r\\n     * greater than largest int192).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int192` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 192 bits\\r\\n     */\\r\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\r\\n        downcasted = int192(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(192, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int184 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int184 or\\r\\n     * greater than largest int184).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int184` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 184 bits\\r\\n     */\\r\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\r\\n        downcasted = int184(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(184, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int176 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int176 or\\r\\n     * greater than largest int176).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int176` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 176 bits\\r\\n     */\\r\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\r\\n        downcasted = int176(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(176, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int168 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int168 or\\r\\n     * greater than largest int168).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int168` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 168 bits\\r\\n     */\\r\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\r\\n        downcasted = int168(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(168, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int160 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int160 or\\r\\n     * greater than largest int160).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int160` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 160 bits\\r\\n     */\\r\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\r\\n        downcasted = int160(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(160, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int152 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int152 or\\r\\n     * greater than largest int152).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int152` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 152 bits\\r\\n     */\\r\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\r\\n        downcasted = int152(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(152, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int144 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int144 or\\r\\n     * greater than largest int144).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int144` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 144 bits\\r\\n     */\\r\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\r\\n        downcasted = int144(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(144, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int136 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int136 or\\r\\n     * greater than largest int136).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int136` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 136 bits\\r\\n     */\\r\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\r\\n        downcasted = int136(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(136, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int128 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int128 or\\r\\n     * greater than largest int128).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int128` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 128 bits\\r\\n     */\\r\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\r\\n        downcasted = int128(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(128, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int120 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int120 or\\r\\n     * greater than largest int120).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int120` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 120 bits\\r\\n     */\\r\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\r\\n        downcasted = int120(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(120, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int112 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int112 or\\r\\n     * greater than largest int112).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int112` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 112 bits\\r\\n     */\\r\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\r\\n        downcasted = int112(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(112, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int104 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int104 or\\r\\n     * greater than largest int104).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int104` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 104 bits\\r\\n     */\\r\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\r\\n        downcasted = int104(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(104, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int96 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int96 or\\r\\n     * greater than largest int96).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int96` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 96 bits\\r\\n     */\\r\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\r\\n        downcasted = int96(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(96, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int88 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int88 or\\r\\n     * greater than largest int88).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int88` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 88 bits\\r\\n     */\\r\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\r\\n        downcasted = int88(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(88, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int80 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int80 or\\r\\n     * greater than largest int80).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int80` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 80 bits\\r\\n     */\\r\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\r\\n        downcasted = int80(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(80, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int72 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int72 or\\r\\n     * greater than largest int72).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int72` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 72 bits\\r\\n     */\\r\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\r\\n        downcasted = int72(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(72, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int64 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int64 or\\r\\n     * greater than largest int64).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int64` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 64 bits\\r\\n     */\\r\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\r\\n        downcasted = int64(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(64, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int56 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int56 or\\r\\n     * greater than largest int56).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int56` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 56 bits\\r\\n     */\\r\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\r\\n        downcasted = int56(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(56, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int48 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int48 or\\r\\n     * greater than largest int48).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int48` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 48 bits\\r\\n     */\\r\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\r\\n        downcasted = int48(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(48, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int40 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int40 or\\r\\n     * greater than largest int40).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int40` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 40 bits\\r\\n     */\\r\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\r\\n        downcasted = int40(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(40, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int32 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int32 or\\r\\n     * greater than largest int32).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int32` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 32 bits\\r\\n     */\\r\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\r\\n        downcasted = int32(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(32, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int24 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int24 or\\r\\n     * greater than largest int24).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int24` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 24 bits\\r\\n     */\\r\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\r\\n        downcasted = int24(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(24, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int16 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int16 or\\r\\n     * greater than largest int16).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int16` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 16 bits\\r\\n     */\\r\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\r\\n        downcasted = int16(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(16, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the downcasted int8 from int256, reverting on\\r\\n     * overflow (when the input is less than smallest int8 or\\r\\n     * greater than largest int8).\\r\\n     *\\r\\n     * Counterpart to Solidity's `int8` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must fit into 8 bits\\r\\n     */\\r\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\r\\n        downcasted = int8(value);\\r\\n        if (downcasted != value) {\\r\\n            revert SafeCastOverflowedIntDowncast(8, value);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an unsigned uint256 into a signed int256.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - input must be less than or equal to maxInt256.\\r\\n     */\\r\\n    function toInt256(uint256 value) internal pure returns (int256) {\\r\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\r\\n        if (value > uint256(type(int256).max)) {\\r\\n            revert SafeCastOverflowedUintToInt(value);\\r\\n        }\\r\\n        return int256(value);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x59dfb05d8c079ed040a83aace6ef0e1e46d76924c17393ed7cf2fd3948ce390b\",\"license\":\"MIT\"},\"risc0/IRiscZeroVerifier.sol\":{\"content\":\"// Copyright 2024 RISC Zero, Inc.\\r\\n//\\r\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\r\\n// you may not use this file except in compliance with the License.\\r\\n// You may obtain a copy of the License at\\r\\n//\\r\\n//     http://www.apache.org/licenses/LICENSE-2.0\\r\\n//\\r\\n// Unless required by applicable law or agreed to in writing, software\\r\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\r\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\r\\n// See the License for the specific language governing permissions and\\r\\n// limitations under the License.\\r\\n//\\r\\n// SPDX-License-Identifier: Apache-2.0\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\n/// @notice Public claims about a zkVM guest execution, such as the journal committed to by the guest.\\r\\n/// @dev Also includes important information such as the exit code and the starting and ending system\\r\\n/// state (i.e. the state of memory). `ReceiptClaim` is a \\\"Merkle-ized struct\\\" supporting\\r\\n/// partial openings of the underlying fields from a hash commitment to the full structure.\\r\\nstruct ReceiptClaim {\\r\\n    /// @notice Digest of the SystemState just before execution has begun.\\r\\n    bytes32 preStateDigest;\\r\\n    /// @notice Digest of the SystemState just after execution has completed.\\r\\n    bytes32 postStateDigest;\\r\\n    /// @notice The exit code for the execution.\\r\\n    ExitCode exitCode;\\r\\n    /// @notice A digest of the input to the guest.\\r\\n    /// @dev This field is currently unused and must be set to the zero digest.\\r\\n    bytes32 input;\\r\\n    /// @notice Digest of the Output of the guest, including the journal\\r\\n    /// and assumptions set during execution.\\r\\n    bytes32 output;\\r\\n}\\r\\n\\r\\nlibrary ReceiptClaimLib {\\r\\n    bytes32 constant TAG_DIGEST = sha256(\\\"risc0.ReceiptClaim\\\");\\r\\n\\r\\n    function digest(ReceiptClaim memory claim) internal pure returns (bytes32) {\\r\\n        return sha256(\\r\\n            abi.encodePacked(\\r\\n                TAG_DIGEST,\\r\\n                // down\\r\\n                claim.input,\\r\\n                claim.preStateDigest,\\r\\n                claim.postStateDigest,\\r\\n                claim.output,\\r\\n                // data\\r\\n                uint32(claim.exitCode.system) << 24,\\r\\n                uint32(claim.exitCode.user) << 24,\\r\\n                // down.length\\r\\n                uint16(4) << 8\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice Exit condition indicated by the zkVM at the end of the guest execution.\\r\\n/// @dev Exit codes have a \\\"system\\\" part and a \\\"user\\\" part. Semantically, the system part is set to\\r\\n/// indicate the type of exit (e.g. halt, pause, or system split) and is directly controlled by the\\r\\n/// zkVM. The user part is an exit code, similar to exit codes used in Linux, chosen by the guest\\r\\n/// program to indicate additional information (e.g. 0 to indicate success or 1 to indicate an\\r\\n/// error).\\r\\nstruct ExitCode {\\r\\n    SystemExitCode system;\\r\\n    uint8 user;\\r\\n}\\r\\n\\r\\n/// @notice Exit condition indicated by the zkVM at the end of the execution covered by this proof.\\r\\n/// @dev\\r\\n/// `Halted` indicates normal termination of a program with an interior exit code returned from the\\r\\n/// guest program. A halted program cannot be resumed.\\r\\n///\\r\\n/// `Paused` indicates the execution ended in a paused state with an interior exit code set by the\\r\\n/// guest program. A paused program can be resumed such that execution picks up where it left\\r\\n/// of, with the same memory state.\\r\\n///\\r\\n/// `SystemSplit` indicates the execution ended on a host-initiated system split. System split is\\r\\n/// mechanism by which the host can temporarily stop execution of the execution ended in a system\\r\\n/// split has no output and no conclusions can be drawn about whether the program will eventually\\r\\n/// halt. System split is used in continuations to split execution into individually provable segments.\\r\\nenum SystemExitCode {\\r\\n    Halted,\\r\\n    Paused,\\r\\n    SystemSplit\\r\\n}\\r\\n\\r\\n/// @notice Output field in the `ReceiptClaim`, committing to a claimed journal and assumptions list.\\r\\nstruct Output {\\r\\n    /// @notice Digest of the journal committed to by the guest execution.\\r\\n    bytes32 journalDigest;\\r\\n    /// @notice Digest of the ordered list of `ReceiptClaim` digests corresponding to the\\r\\n    /// calls to `env::verify` and `env::verify_integrity`.\\r\\n    /// @dev Verifying the integrity of a `Receipt` corresponding to a `ReceiptClaim` with a\\r\\n    /// non-empty assumptions list does not guarantee unconditionally any of the claims over the\\r\\n    /// guest execution (i.e. if the assumptions list is non-empty, then the journal digest cannot\\r\\n    /// be trusted to correspond to a genuine execution). The claims can be checked by additional\\r\\n    /// verifying a `Receipt` for every digest in the assumptions list.\\r\\n    bytes32 assumptionsDigest;\\r\\n}\\r\\n\\r\\nlibrary OutputLib {\\r\\n    bytes32 constant TAG_DIGEST = sha256(\\\"risc0.Output\\\");\\r\\n\\r\\n    function digest(Output memory output) internal pure returns (bytes32) {\\r\\n        return sha256(\\r\\n            abi.encodePacked(\\r\\n                TAG_DIGEST,\\r\\n                // down\\r\\n                output.journalDigest,\\r\\n                output.assumptionsDigest,\\r\\n                // down.length\\r\\n                uint16(2) << 8\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n}\\r\\n\\r\\n/// @notice A receipt attesting to the execution of a guest program.\\r\\n/// @dev A receipt contains two parts: a seal and a claim. The seal is a zero-knowledge proof\\r\\n/// attesting to knowledge of a zkVM execution resulting in the claim. The claim is a set of public\\r\\n/// outputs for the execution. Crucially, the claim includes the journal and the image ID. The\\r\\n/// image ID identifies the program that was executed, and the journal is the public data written\\r\\n/// by the program.\\r\\nstruct Receipt {\\r\\n    bytes seal;\\r\\n    ReceiptClaim claim;\\r\\n}\\r\\n\\r\\n/// @notice Verifier interface for RISC Zero receipts of execution.\\r\\ninterface IRiscZeroVerifier {\\r\\n    /// @notice Verify that the given seal is a valid RISC Zero proof of execution with the\\r\\n    ///     given image ID, post-state digest, and journal digest.\\r\\n    /// @dev This method additionally ensures that the input hash is all-zeros (i.e. no\\r\\n    /// committed input), the exit code is (Halted, 0), and there are no assumptions (i.e. the\\r\\n    /// receipt is unconditional).\\r\\n    /// @param seal The encoded cryptographic proof (i.e. SNARK).\\r\\n    /// @param imageId The identifier for the guest program.\\r\\n    /// @param postStateDigest A hash of the final memory state. Required to run the verifier, but\\r\\n    ///     otherwise can be left unconstrained for most use cases.\\r\\n    /// @param journalDigest The SHA-256 digest of the journal bytes.\\r\\n    /// @return true if the receipt passes the verification checks. The return code must be checked.\\r\\n    function verify(bytes calldata seal, bytes32 imageId, bytes32 postStateDigest, bytes32 journalDigest)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    /// @notice Verify that the given receipt is a valid RISC Zero receipt, ensuring the `seal` is\\r\\n    /// valid a cryptographic proof of the execution with the given `claim`.\\r\\n    /// @param receipt The receipt to be verified.\\r\\n    /// @return true if the receipt passes the verification checks. The return code must be checked.\\r\\n    function verify_integrity(Receipt calldata receipt) external view returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0xab19c099edd9a3c4017b60bc4d70446c47bfc648b4f23a29209b9a5d25197908\",\"license\":\"Apache-2.0\"},\"risc0/groth16/ControlID.sol\":{\"content\":\"// Copyright 2024 RISC Zero, Inc.\\r\\n//\\r\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\r\\n// you may not use this file except in compliance with the License.\\r\\n// You may obtain a copy of the License at\\r\\n//\\r\\n//     http://www.apache.org/licenses/LICENSE-2.0\\r\\n//\\r\\n// Unless required by applicable law or agreed to in writing, software\\r\\n// distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\r\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\r\\n// See the License for the specific language governing permissions and\\r\\n// limitations under the License.\\r\\n//\\r\\n// SPDX-License-Identifier: Apache-2.0\\r\\n\\r\\n// This file is automatically generated by:\\r\\n// cargo xtask bootstrap-groth16\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nlibrary ControlID {\\r\\n    uint256 public constant CONTROL_ID_0 = 0x39ff805954f4eb2868d338764408f76d;\\r\\n    uint256 public constant CONTROL_ID_1 = 0x15cf3a5f4097269e3a6d921c18625531;\\r\\n}\\r\\n\",\"keccak256\":\"0x45e863702fec6424d68b724560a110ea1f593d7e3ca011be14443fe3c4cecf9d\",\"license\":\"Apache-2.0\"},\"risc0/groth16/Groth16Verifier.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\r\\n/*\\r\\n    Copyright 2021 0KIMS association.\\r\\n\\r\\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\\r\\n\\r\\n    snarkJS is a free software: you can redistribute it and/or modify it\\r\\n    under the terms of the GNU General Public License as published by\\r\\n    the Free Software Foundation, either version 3 of the License, or\\r\\n    (at your option) any later version.\\r\\n\\r\\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\\r\\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\\r\\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\\r\\n    License for more details.\\r\\n\\r\\n    You should have received a copy of the GNU General Public License\\r\\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\\r\\n*/\\r\\n\\r\\npragma solidity >=0.7.0 <0.9.0;\\r\\n\\r\\ncontract Groth16Verifier {\\r\\n    // Scalar field size\\r\\n    uint256 constant r = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\r\\n    // Base field size\\r\\n    uint256 constant q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\r\\n\\r\\n    // Verification Key data\\r\\n    uint256 constant alphax = 20491192805390485299153009773594534940189261866228447918068658471970481763042;\\r\\n    uint256 constant alphay = 9383485363053290200918347156157836566562967994039712273449902621266178545958;\\r\\n    uint256 constant betax1 = 4252822878758300859123897981450591353533073413197771768651442665752259397132;\\r\\n    uint256 constant betax2 = 6375614351688725206403948262868962793625744043794305715222011528459656738731;\\r\\n    uint256 constant betay1 = 21847035105528745403288232691147584728191162732299865338377159692350059136679;\\r\\n    uint256 constant betay2 = 10505242626370262277552901082094356697409835680220590971873171140371331206856;\\r\\n    uint256 constant gammax1 = 11559732032986387107991004021392285783925812861821192530917403151452391805634;\\r\\n    uint256 constant gammax2 = 10857046999023057135944570762232829481370756359578518086990519993285655852781;\\r\\n    uint256 constant gammay1 = 4082367875863433681332203403145435568316851327593401208105741076214120093531;\\r\\n    uint256 constant gammay2 = 8495653923123431417604973247489272438418190587263600148770280649306958101930;\\r\\n    uint256 constant deltax1 = 20637939757332191985219466750514112514830176492003070298908178796582256423445;\\r\\n    uint256 constant deltax2 = 21015870987554935578856562994563796394452175083269944606559673949460277152483;\\r\\n    uint256 constant deltay1 = 7308971620370004609743038871778988943972318366181842608509263947408591078846;\\r\\n    uint256 constant deltay2 = 19578762133483017273429849028797807252406479590275449312036317638112265649126;\\r\\n\\r\\n    uint256 constant IC0x = 4595639739788529313135927846153489513260052783364743523344328896305419933627;\\r\\n    uint256 constant IC0y = 13577843718844184042346095806470311065274840502864234728407198439361979518223;\\r\\n\\r\\n    uint256 constant IC1x = 19125733112813331880180112762042920784001527126678496097978721184513458499861;\\r\\n    uint256 constant IC1y = 470495054354753477176064253439657941845200056447070007550476843795069859530;\\r\\n\\r\\n    uint256 constant IC2x = 9798632009143333403145042225641105799474060066926099950339875153142594918323;\\r\\n    uint256 constant IC2y = 15467851970301286525906423722646678659414362276892586739627188622113917076355;\\r\\n\\r\\n    uint256 constant IC3x = 4677856832410602822119633312864839150180396112709578634305606190993420950086;\\r\\n    uint256 constant IC3y = 21413789555508871663216491538642005537595601774930793267108872091881334409985;\\r\\n\\r\\n    uint256 constant IC4x = 17622463197037705164686879153818888337611670039316323149958751021262085916949;\\r\\n    uint256 constant IC4y = 10546326028888365743245970980969672597991412490319907398941581639510925080455;\\r\\n\\r\\n    // Memory data\\r\\n    uint16 constant pVk = 0;\\r\\n    uint16 constant pPairing = 128;\\r\\n\\r\\n    uint16 constant pLastMem = 896;\\r\\n\\r\\n    function verifyProof(\\r\\n        uint256[2] calldata _pA,\\r\\n        uint256[2][2] calldata _pB,\\r\\n        uint256[2] calldata _pC,\\r\\n        uint256[4] calldata _pubSignals\\r\\n    ) public view returns (bool) {\\r\\n        assembly {\\r\\n            function checkField(v) {\\r\\n                if iszero(lt(v, q)) {\\r\\n                    mstore(0, 0)\\r\\n                    return(0, 0x20)\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // G1 function to multiply a G1 value(x,y) to value in an address\\r\\n            function g1_mulAccC(pR, x, y, s) {\\r\\n                let success\\r\\n                let mIn := mload(0x40)\\r\\n                mstore(mIn, x)\\r\\n                mstore(add(mIn, 32), y)\\r\\n                mstore(add(mIn, 64), s)\\r\\n\\r\\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\\r\\n\\r\\n                if iszero(success) {\\r\\n                    mstore(0, 0)\\r\\n                    return(0, 0x20)\\r\\n                }\\r\\n\\r\\n                mstore(add(mIn, 64), mload(pR))\\r\\n                mstore(add(mIn, 96), mload(add(pR, 32)))\\r\\n\\r\\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\\r\\n\\r\\n                if iszero(success) {\\r\\n                    mstore(0, 0)\\r\\n                    return(0, 0x20)\\r\\n                }\\r\\n            }\\r\\n\\r\\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\\r\\n                let _pPairing := add(pMem, pPairing)\\r\\n                let _pVk := add(pMem, pVk)\\r\\n\\r\\n                mstore(_pVk, IC0x)\\r\\n                mstore(add(_pVk, 32), IC0y)\\r\\n\\r\\n                // Compute the linear combination vk_x\\r\\n\\r\\n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\\r\\n\\r\\n                g1_mulAccC(_pVk, IC2x, IC2y, calldataload(add(pubSignals, 32)))\\r\\n\\r\\n                g1_mulAccC(_pVk, IC3x, IC3y, calldataload(add(pubSignals, 64)))\\r\\n\\r\\n                g1_mulAccC(_pVk, IC4x, IC4y, calldataload(add(pubSignals, 96)))\\r\\n\\r\\n                // -A\\r\\n                mstore(_pPairing, calldataload(pA))\\r\\n                mstore(add(_pPairing, 32), mod(sub(q, calldataload(add(pA, 32))), q))\\r\\n\\r\\n                // B\\r\\n                mstore(add(_pPairing, 64), calldataload(pB))\\r\\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\\r\\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\\r\\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\\r\\n\\r\\n                // alpha1\\r\\n                mstore(add(_pPairing, 192), alphax)\\r\\n                mstore(add(_pPairing, 224), alphay)\\r\\n\\r\\n                // beta2\\r\\n                mstore(add(_pPairing, 256), betax1)\\r\\n                mstore(add(_pPairing, 288), betax2)\\r\\n                mstore(add(_pPairing, 320), betay1)\\r\\n                mstore(add(_pPairing, 352), betay2)\\r\\n\\r\\n                // vk_x\\r\\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\\r\\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\\r\\n\\r\\n                // gamma2\\r\\n                mstore(add(_pPairing, 448), gammax1)\\r\\n                mstore(add(_pPairing, 480), gammax2)\\r\\n                mstore(add(_pPairing, 512), gammay1)\\r\\n                mstore(add(_pPairing, 544), gammay2)\\r\\n\\r\\n                // C\\r\\n                mstore(add(_pPairing, 576), calldataload(pC))\\r\\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\\r\\n\\r\\n                // delta2\\r\\n                mstore(add(_pPairing, 640), deltax1)\\r\\n                mstore(add(_pPairing, 672), deltax2)\\r\\n                mstore(add(_pPairing, 704), deltay1)\\r\\n                mstore(add(_pPairing, 736), deltay2)\\r\\n\\r\\n                let success := staticcall(sub(gas(), 2000), 8, _pPairing, 768, _pPairing, 0x20)\\r\\n\\r\\n                isOk := and(success, mload(_pPairing))\\r\\n            }\\r\\n\\r\\n            let pMem := mload(0x40)\\r\\n            mstore(0x40, add(pMem, pLastMem))\\r\\n\\r\\n            // Validate that all evaluations \\u2208 F\\r\\n\\r\\n            checkField(calldataload(add(_pubSignals, 0)))\\r\\n\\r\\n            checkField(calldataload(add(_pubSignals, 32)))\\r\\n\\r\\n            checkField(calldataload(add(_pubSignals, 64)))\\r\\n\\r\\n            checkField(calldataload(add(_pubSignals, 96)))\\r\\n\\r\\n            checkField(calldataload(add(_pubSignals, 128)))\\r\\n\\r\\n            // Validate all evaluations\\r\\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\\r\\n\\r\\n            mstore(0, isValid)\\r\\n            return(0, 0x20)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x822c9bd1cf81e7ac40fbba8146c7db28d5fefaa739b27185399d37356b25cc0b\",\"license\":\"GPL-3.0\"},\"risc0/groth16/RiscZeroGroth16Verifier.sol\":{\"content\":\"// Copyright 2024 RISC Zero, Inc.\\r\\n//\\r\\n// The RiscZeroGroth16Verifier is a free software: you can redistribute it\\r\\n// and/or modify it under the terms of the GNU General Public License as\\r\\n// published by the Free Software Foundation, either version 3 of the License,\\r\\n// or (at your option) any later version.\\r\\n//\\r\\n// The RiscZeroGroth16Verifier is distributed in the hope that it will be\\r\\n// useful, but WITHOUT ANY WARRANTY; without even the implied warranty of\\r\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General\\r\\n// Public License for more details.\\r\\n//\\r\\n// You should have received a copy of the GNU General Public License along with\\r\\n// the RiscZeroGroth16Verifier. If not, see <https://www.gnu.org/licenses/>.\\r\\n//\\r\\n// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport {SafeCast} from \\\"openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\r\\n\\r\\nimport {ControlID} from \\\"./ControlID.sol\\\";\\r\\nimport {Groth16Verifier} from \\\"./Groth16Verifier.sol\\\";\\r\\nimport {\\r\\n    ExitCode,\\r\\n    IRiscZeroVerifier,\\r\\n    Output,\\r\\n    OutputLib,\\r\\n    Receipt,\\r\\n    ReceiptClaim,\\r\\n    ReceiptClaimLib,\\r\\n    SystemExitCode\\r\\n} from \\\"../IRiscZeroVerifier.sol\\\";\\r\\n\\r\\n/// @notice reverse the byte order of the uint256 value.\\r\\n/// @dev Soldity uses a big-endian ABI encoding. Reversing the byte order before encoding\\r\\n/// ensure that the encoded value will be little-endian.\\r\\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\\r\\nfunction reverseByteOrderUint256(uint256 input) pure returns (uint256 v) {\\r\\n    v = input;\\r\\n\\r\\n    // swap bytes\\r\\n    v = ((v & 0xFF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00) >> 8)\\r\\n        | ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\\r\\n\\r\\n    // swap 2-byte long pairs\\r\\n    v = ((v & 0xFFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000) >> 16)\\r\\n        | ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\\r\\n\\r\\n    // swap 4-byte long pairs\\r\\n    v = ((v & 0xFFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000) >> 32)\\r\\n        | ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\\r\\n\\r\\n    // swap 8-byte long pairs\\r\\n    v = ((v & 0xFFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF0000000000000000) >> 64)\\r\\n        | ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\\r\\n\\r\\n    // swap 16-byte long pairs\\r\\n    v = (v >> 128) | (v << 128);\\r\\n}\\r\\n\\r\\n/// @notice reverse the byte order of the uint32 value.\\r\\n/// @dev Soldity uses a big-endian ABI encoding. Reversing the byte order before encoding\\r\\n/// ensure that the encoded value will be little-endian.\\r\\n/// Written by k06a. https://ethereum.stackexchange.com/a/83627\\r\\nfunction reverseByteOrderUint32(uint32 input) pure returns (uint32 v) {\\r\\n    v = input;\\r\\n\\r\\n    // swap bytes\\r\\n    v = ((v & 0xFF00FF00) >> 8) | ((v & 0x00FF00FF) << 8);\\r\\n\\r\\n    // swap 2-byte long pairs\\r\\n    v = (v >> 16) | (v << 16);\\r\\n}\\r\\n\\r\\n/// @notice A Groth16 seal over the claimed receipt claim.\\r\\nstruct Seal {\\r\\n    uint256[2] a;\\r\\n    uint256[2][2] b;\\r\\n    uint256[2] c;\\r\\n}\\r\\n\\r\\n/// @notice Groth16 verifier contract for RISC Zero receipts of execution.\\r\\ncontract RiscZeroGroth16Verifier is IRiscZeroVerifier, Groth16Verifier {\\r\\n    using ReceiptClaimLib for ReceiptClaim;\\r\\n    using OutputLib for Output;\\r\\n    using SafeCast for uint256;\\r\\n\\r\\n    /// @notice Control ID hash for the identity_p254 predicate decomposed by `splitDigest`.\\r\\n    /// @dev This value controls what set of recursion programs, and therefore what version of the\\r\\n    /// zkVM circuit, will be accepted by this contract. Each instance of this verifier contract\\r\\n    /// will accept a single release of the RISC Zero circuits.\\r\\n    ///\\r\\n    /// New releases of RISC Zero's zkVM require updating these values. These values can be\\r\\n    /// obtained by running `cargo run --bin bonsai-ethereum-contracts -F control-id`\\r\\n    uint256 public immutable CONTROL_ID_0;\\r\\n    uint256 public immutable CONTROL_ID_1;\\r\\n\\r\\n    constructor(uint256 control_id_0, uint256 control_id_1) {\\r\\n        CONTROL_ID_0 = control_id_0;\\r\\n        CONTROL_ID_1 = control_id_1;\\r\\n    }\\r\\n\\r\\n    /// @notice splits a digest into two 128-bit words to use as public signal inputs.\\r\\n    /// @dev RISC Zero's Circom verifier circuit takes each of two hash digests in two 128-bit\\r\\n    /// chunks. These values can be derived from the digest by splitting the digest in half and\\r\\n    /// then reversing the bytes of each.\\r\\n    function splitDigest(bytes32 digest) internal pure returns (uint256, uint256) {\\r\\n        uint256 reversed = reverseByteOrderUint256(uint256(digest));\\r\\n        return (uint256(uint128(uint256(reversed))), uint256(reversed >> 128));\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IRiscZeroVerifier\\r\\n    function verify(bytes calldata seal, bytes32 imageId, bytes32 postStateDigest, bytes32 journalDigest)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        Receipt memory receipt = Receipt(\\r\\n            seal,\\r\\n            ReceiptClaim(\\r\\n                imageId,\\r\\n                postStateDigest,\\r\\n                ExitCode(SystemExitCode.Halted, 0),\\r\\n                bytes32(0),\\r\\n                Output(journalDigest, bytes32(0)).digest()\\r\\n            )\\r\\n        );\\r\\n        return verify_integrity(receipt);\\r\\n    }\\r\\n\\r\\n    /// @inheritdoc IRiscZeroVerifier\\r\\n    function verify_integrity(Receipt memory receipt) public view returns (bool) {\\r\\n        (uint256 claim0, uint256 claim1) = splitDigest(receipt.claim.digest());\\r\\n        Seal memory seal = abi.decode(receipt.seal, (Seal));\\r\\n        return this.verifyProof(seal.a, seal.b, seal.c, [CONTROL_ID_0, CONTROL_ID_1, claim0, claim1]);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x550646c988ca567de1b1785acf025e2617b97fc3d813de2403610ff7c5059cc0\",\"license\":\"GPL-3.0\"}},\"version\":1}",
  "bytecode": "0x60c060405234801561001057600080fd5b506f39ff805954f4eb2868d338764408f76d6080526f15cf3a5f4097269e3a6d921c1862553160a05260805160a05161115461006a6000396000818160e401526101910152600081816061015261016b01526111546000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c8063168b11461461005c5780631bb8068f146100965780635fe8c13b146100b95780636efef009146100cc57806386039a31146100df575b600080fd5b6100837f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6100a96100a4366004610d07565b610106565b604051901515815260200161008d565b6100a96100c7366004610dfb565b610228565b6100a96100da366004610e55565b6107a0565b6100837f000000000000000000000000000000000000000000000000000000000000000081565b600080600061012061011b856020015161084f565b6109b4565b915091506000846000015180602001905181019061013e9190610f2d565b9050306001600160a01b0316635fe8c13b82600001518360200151846040015160405180608001604052807f000000000000000000000000000000000000000000000000000000000000000081526020017f00000000000000000000000000000000000000000000000000000000000000008152602001898152602001888152506040518563ffffffff1660e01b81526004016101de9493929190610ff0565b602060405180830381865afa1580156101fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061021f9190611097565b95945050505050565b600061073b565b7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd478110610260576000805260206000f35b50565b600060405183815284602082015285604082015260408160608360076107d05a03fa915081610296576000805260206000f35b825160408201526020830151606082015260408360808360066107d05a03fa915050806102c7576000805260206000f35b5050505050565b7f0a290a37e44495f8ba6f79b790a262a73130a55a228e288ef18d4ea322be57bb85527f1e04c986599fc5c27efa1e96335b142c9af7c665db8cc2beec2df46a413a8d0f60208601526000608086018661036b87357f010a4a6f7eaba5eb044fca50e7c0bf141855fdc799bba8df8613fbfb8fb4f6ca7f2a48c804fc0a598530f368cec38e4ffa1c28ea493c5974795cb753752cdcf11584610263565b6103bb60208801357f22327e74a9614ae127168748cf3be7e4b1b97e95b62100cc614de340bc9b83837f15a9d4452a9749d08cf15886ff3dbdb6d5241cb2bb3305f8359161653e9bd7b384610263565b61040b60408801357f2f57c67f49c731842f676749e686e0f65a397ccf0ac98dceddbe2adde6808b017f0a5792b9591ec6c58fe22e0de47c9d5a50a51305c316cd53ce5d2cfafd499a4684610263565b61045b60608801357f1751024dbc2dec7470617907ddf19a7d48601b86b937bbe1065579c11e5977877f26f5f5f0cea15dd7b79310095e6052b62eee2b5bfc2d2125802801df17bd891584610263565b50823581527f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4760208401357f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4703066020820152833560408201526020840135606082015260408401356080820152606084013560a08201527f2d4d9aa7e302d9df41749d5507949d05dbea33fbb16c643b22f599a2be6df2e260c08201527f14bedd503c37ceb061d8ec60209fe345ce89830a19230301f076caff004d192660e08201527f0967032fcbf776d1afc985f88877f182d38480a653f2decaa9794cbc3bf3060c6101008201527f0e187847ad4c798374d0d6732bf501847dd68bc0e071241e0213bc7fc13db7ab6101208201527f304cfbd1e08a704a99f5e847d93f8c3caafddec46b7a0d379da69a4d112346a76101408201527f1739c1b1a457a8c7313123d24d2f9192f896b7c63eea05a9d57f06547ad0cec8610160820152600087015161018082015260206000018701516101a08201527f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c26101c08201527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed6101e08201527f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b6102008201527f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa610220820152843561024082015260208501356102608201527f2da0a8f2daa8496a8f3fcc27be3a6f95d0fd194c104cc2561ae945b9ef62b2156102808201527f2e768fbb4a79cc667c24913b8ea6130949faee1b4ef9e492dd083a705a7ecae36102a08201527f1028bb38e50f245677993cd944b3ff74af7bf9f7527cee8e604c6220a848c5be6102c08201527f2b492fc9489ac9d6041f3836baf93a109f9253529d8012e01ce011c316c83be66102e08201526020816103008360086107d05a03fa9051169695505050505050565b6040516103808101604052610753600084013561022f565b610760602084013561022f565b61076d604084013561022f565b61077a606084013561022f565b610787608084013561022f565b610794818486888a6102ce565b90508060005260206000f35b6040805160606020601f88018190040282018101835291810186815260009283929182918a908a9081908501838280828437600092018290525093855250506040805160a0810182528a815260208082018b9052825180840184528581528082018690528284015260608201859052825180840190935289835282810194909452929093019260808301915061083590610b23565b90529052905061084481610106565b979650505050505050565b6000600280604051610879907172697363302e52656365697074436c61696d60701b815260120190565b602060405180830381855afa158015610896573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906108b991906110d6565b606084015184516020860151608087015160408801515160189060028111156108e4576108e46110c0565b60408a810151602090810151825191820199909952908101969096526060860194909452608085019290925260a084015263ffffffff909116901b60e01b6001600160e01b03191660c082015260f89190911b6001600160f81b03191660c4820152600160fa1b60c882015260ca015b60408051601f198184030181529082905261096e916110ef565b602060405180830381855afa15801561098b573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906109ae91906110d6565b92915050565b60008080610b018460008190506008817eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff16901b6008827fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff0016901c1790506010817dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff16901b6010827fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff000016901c1790506020817bffffffff00000000ffffffff00000000ffffffff00000000ffffffff16901b6020827fffffffff00000000ffffffff00000000ffffffff00000000ffffffff0000000016901c17905060408177ffffffffffffffff0000000000000000ffffffffffffffff16901b60408277ffffffffffffffff0000000000000000ffffffffffffffff1916901c179050608081901b608082901c179050919050565b6fffffffffffffffffffffffffffffffff81169560809190911c945092505050565b6000600280604051610b47906b1c9a5cd8cc0b93dd5d1c1d5d60a21b8152600c0190565b602060405180830381855afa158015610b64573d6000803e3d6000fd5b5050506040513d601f19601f82011682018060405250810190610b8791906110d6565b83516020808601516040805192830194909452928101919091526060810191909152600160f91b6080820152608201610954565b634e487b7160e01b600052604160045260246000fd5b60405160a0810167ffffffffffffffff81118282101715610bf457610bf4610bbb565b60405290565b6040805190810167ffffffffffffffff81118282101715610bf457610bf4610bbb565b6040516060810167ffffffffffffffff81118282101715610bf457610bf4610bbb565b604051601f8201601f1916810167ffffffffffffffff81118282101715610c6957610c69610bbb565b604052919050565b600081830360c0811215610c8457600080fd5b610c8c610bd1565b915082358252602083013560208301526040603f1982011215610cae57600080fd5b50610cb7610bfa565b604083013560038110610cc957600080fd5b8152606083013560ff81168114610cdf57600080fd5b80602083015250806040830152506080820135606082015260a0820135608082015292915050565b60006020808385031215610d1a57600080fd5b823567ffffffffffffffff80821115610d3257600080fd5b9084019060e08287031215610d4657600080fd5b610d4e610bfa565b823582811115610d5d57600080fd5b8301601f81018813610d6e57600080fd5b803583811115610d8057610d80610bbb565b610d92601f8201601f19168701610c40565b93508084528886828401011115610da857600080fd5b8086830187860137600090840186015250818152610dc887848601610c71565b848201528094505050505092915050565b80604081018310156109ae57600080fd5b80608081018310156109ae57600080fd5b6000806000806101808587031215610e1257600080fd5b610e1c8686610dd9565b9350610e2b8660408701610dea565b9250610e3a8660c08701610dd9565b9150610e4a866101008701610dea565b905092959194509250565b600080600080600060808688031215610e6d57600080fd5b853567ffffffffffffffff80821115610e8557600080fd5b818801915088601f830112610e9957600080fd5b813581811115610ea857600080fd5b896020828501011115610eba57600080fd5b60209283019a909950918801359760408101359750606001359550909350505050565b600082601f830112610eee57600080fd5b610ef6610bfa565b806040840185811115610f0857600080fd5b845b81811015610f22578051845260209384019301610f0a565b509095945050505050565b60006101008284031215610f4057600080fd5b610f48610c1d565b610f528484610edd565b8152604084605f850112610f6557600080fd5b610f6d610bfa565b8060c0860187811115610f7f57600080fd5b8387015b81811015610fa457610f958982610edd565b84526020909301928401610f83565b50816020860152610fb58882610edd565b84860152505050508091505092915050565b8060005b6002811015610fea578151845260209384019390910190600101610fcb565b50505050565b6101808101610fff8287610fc7565b60408083018660005b60028082106110175750611052565b82518460005b8381101561103b57825182526020928301929091019060010161101d565b505050928401925060209190910190600101611008565b5050505061106360c0830185610fc7565b61010082018360005b600481101561108b57815183526020928301929091019060010161106c565b50505095945050505050565b6000602082840312156110a957600080fd5b815180151581146110b957600080fd5b9392505050565b634e487b7160e01b600052602160045260246000fd5b6000602082840312156110e857600080fd5b5051919050565b6000825160005b8181101561111057602081860181015185830152016110f6565b50600092019182525091905056fea264697066735822122006cda0c98e2f9acd1e09be3a9d0efc25b33d6a38d38066c6bb00e651a66c2d7e64736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c8063168b11461461005c5780631bb8068f146100965780635fe8c13b146100b95780636efef009146100cc57806386039a31146100df575b600080fd5b6100837f000000000000000000000000000000000000000000000000000000000000000081565b6040519081526020015b60405180910390f35b6100a96100a4366004610d07565b610106565b604051901515815260200161008d565b6100a96100c7366004610dfb565b610228565b6100a96100da366004610e55565b6107a0565b6100837f000000000000000000000000000000000000000000000000000000000000000081565b600080600061012061011b856020015161084f565b6109b4565b915091506000846000015180602001905181019061013e9190610f2d565b9050306001600160a01b0316635fe8c13b82600001518360200151846040015160405180608001604052807f000000000000000000000000000000000000000000000000000000000000000081526020017f00000000000000000000000000000000000000000000000000000000000000008152602001898152602001888152506040518563ffffffff1660e01b81526004016101de9493929190610ff0565b602060405180830381865afa1580156101fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061021f9190611097565b95945050505050565b600061073b565b7f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd478110610260576000805260206000f35b50565b600060405183815284602082015285604082015260408160608360076107d05a03fa915081610296576000805260206000f35b825160408201526020830151606082015260408360808360066107d05a03fa915050806102c7576000805260206000f35b5050505050565b7f0a290a37e44495f8ba6f79b790a262a73130a55a228e288ef18d4ea322be57bb85527f1e04c986599fc5c27efa1e96335b142c9af7c665db8cc2beec2df46a413a8d0f60208601526000608086018661036b87357f010a4a6f7eaba5eb044fca50e7c0bf141855fdc799bba8df8613fbfb8fb4f6ca7f2a48c804fc0a598530f368cec38e4ffa1c28ea493c5974795cb753752cdcf11584610263565b6103bb60208801357f22327e74a9614ae127168748cf3be7e4b1b97e95b62100cc614de340bc9b83837f15a9d4452a9749d08cf15886ff3dbdb6d5241cb2bb3305f8359161653e9bd7b384610263565b61040b60408801357f2f57c67f49c731842f676749e686e0f65a397ccf0ac98dceddbe2adde6808b017f0a5792b9591ec6c58fe22e0de47c9d5a50a51305c316cd53ce5d2cfafd499a4684610263565b61045b60608801357f1751024dbc2dec7470617907ddf19a7d48601b86b937bbe1065579c11e5977877f26f5f5f0cea15dd7b79310095e6052b62eee2b5bfc2d2125802801df17bd891584610263565b50823581527f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4760208401357f30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd4703066020820152833560408201526020840135606082015260408401356080820152606084013560a08201527f2d4d9aa7e302d9df41749d5507949d05dbea33fbb16c643b22f599a2be6df2e260c08201527f14bedd503c37ceb061d8ec60209fe345ce89830a19230301f076caff004d192660e08201527f0967032fcbf776d1afc985f88877f182d38480a653f2decaa9794cbc3bf3060c6101008201527f0e187847ad4c798374d0d6732bf501847dd68bc0e071241e0213bc7fc13db7ab6101208201527f304cfbd1e08a704a99f5e847d93f8c3caafddec46b7a0d379da69a4d112346a76101408201527f1739c1b1a457a8c7313123d24d2f9192f896b7c63eea05a9d57f06547ad0cec8610160820152600087015161018082015260206000018701516101a08201527f198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c26101c08201527f1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed6101e08201527f090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b6102008201527f12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa610220820152843561024082015260208501356102608201527f2da0a8f2daa8496a8f3fcc27be3a6f95d0fd194c104cc2561ae945b9ef62b2156102808201527f2e768fbb4a79cc667c24913b8ea6130949faee1b4ef9e492dd083a705a7ecae36102a08201527f1028bb38e50f245677993cd944b3ff74af7bf9f7527cee8e604c6220a848c5be6102c08201527f2b492fc9489ac9d6041f3836baf93a109f9253529d8012e01ce011c316c83be66102e08201526020816103008360086107d05a03fa9051169695505050505050565b6040516103808101604052610753600084013561022f565b610760602084013561022f565b61076d604084013561022f565b61077a606084013561022f565b610787608084013561022f565b610794818486888a6102ce565b90508060005260206000f35b6040805160606020601f88018190040282018101835291810186815260009283929182918a908a9081908501838280828437600092018290525093855250506040805160a0810182528a815260208082018b9052825180840184528581528082018690528284015260608201859052825180840190935289835282810194909452929093019260808301915061083590610b23565b90529052905061084481610106565b979650505050505050565b6000600280604051610879907172697363302e52656365697074436c61696d60701b815260120190565b602060405180830381855afa158015610896573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906108b991906110d6565b606084015184516020860151608087015160408801515160189060028111156108e4576108e46110c0565b60408a810151602090810151825191820199909952908101969096526060860194909452608085019290925260a084015263ffffffff909116901b60e01b6001600160e01b03191660c082015260f89190911b6001600160f81b03191660c4820152600160fa1b60c882015260ca015b60408051601f198184030181529082905261096e916110ef565b602060405180830381855afa15801561098b573d6000803e3d6000fd5b5050506040513d601f19601f820116820180604052508101906109ae91906110d6565b92915050565b60008080610b018460008190506008817eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff16901b6008827fff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff0016901c1790506010817dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff16901b6010827fffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff000016901c1790506020817bffffffff00000000ffffffff00000000ffffffff00000000ffffffff16901b6020827fffffffff00000000ffffffff00000000ffffffff00000000ffffffff0000000016901c17905060408177ffffffffffffffff0000000000000000ffffffffffffffff16901b60408277ffffffffffffffff0000000000000000ffffffffffffffff1916901c179050608081901b608082901c179050919050565b6fffffffffffffffffffffffffffffffff81169560809190911c945092505050565b6000600280604051610b47906b1c9a5cd8cc0b93dd5d1c1d5d60a21b8152600c0190565b602060405180830381855afa158015610b64573d6000803e3d6000fd5b5050506040513d601f19601f82011682018060405250810190610b8791906110d6565b83516020808601516040805192830194909452928101919091526060810191909152600160f91b6080820152608201610954565b634e487b7160e01b600052604160045260246000fd5b60405160a0810167ffffffffffffffff81118282101715610bf457610bf4610bbb565b60405290565b6040805190810167ffffffffffffffff81118282101715610bf457610bf4610bbb565b6040516060810167ffffffffffffffff81118282101715610bf457610bf4610bbb565b604051601f8201601f1916810167ffffffffffffffff81118282101715610c6957610c69610bbb565b604052919050565b600081830360c0811215610c8457600080fd5b610c8c610bd1565b915082358252602083013560208301526040603f1982011215610cae57600080fd5b50610cb7610bfa565b604083013560038110610cc957600080fd5b8152606083013560ff81168114610cdf57600080fd5b80602083015250806040830152506080820135606082015260a0820135608082015292915050565b60006020808385031215610d1a57600080fd5b823567ffffffffffffffff80821115610d3257600080fd5b9084019060e08287031215610d4657600080fd5b610d4e610bfa565b823582811115610d5d57600080fd5b8301601f81018813610d6e57600080fd5b803583811115610d8057610d80610bbb565b610d92601f8201601f19168701610c40565b93508084528886828401011115610da857600080fd5b8086830187860137600090840186015250818152610dc887848601610c71565b848201528094505050505092915050565b80604081018310156109ae57600080fd5b80608081018310156109ae57600080fd5b6000806000806101808587031215610e1257600080fd5b610e1c8686610dd9565b9350610e2b8660408701610dea565b9250610e3a8660c08701610dd9565b9150610e4a866101008701610dea565b905092959194509250565b600080600080600060808688031215610e6d57600080fd5b853567ffffffffffffffff80821115610e8557600080fd5b818801915088601f830112610e9957600080fd5b813581811115610ea857600080fd5b896020828501011115610eba57600080fd5b60209283019a909950918801359760408101359750606001359550909350505050565b600082601f830112610eee57600080fd5b610ef6610bfa565b806040840185811115610f0857600080fd5b845b81811015610f22578051845260209384019301610f0a565b509095945050505050565b60006101008284031215610f4057600080fd5b610f48610c1d565b610f528484610edd565b8152604084605f850112610f6557600080fd5b610f6d610bfa565b8060c0860187811115610f7f57600080fd5b8387015b81811015610fa457610f958982610edd565b84526020909301928401610f83565b50816020860152610fb58882610edd565b84860152505050508091505092915050565b8060005b6002811015610fea578151845260209384019390910190600101610fcb565b50505050565b6101808101610fff8287610fc7565b60408083018660005b60028082106110175750611052565b82518460005b8381101561103b57825182526020928301929091019060010161101d565b505050928401925060209190910190600101611008565b5050505061106360c0830185610fc7565b61010082018360005b600481101561108b57815183526020928301929091019060010161106c565b50505095945050505050565b6000602082840312156110a957600080fd5b815180151581146110b957600080fd5b9392505050565b634e487b7160e01b600052602160045260246000fd5b6000602082840312156110e857600080fd5b5051919050565b6000825160005b8181101561111057602081860181015185830152016110f6565b50600092019182525091905056fea264697066735822122006cda0c98e2f9acd1e09be3a9d0efc25b33d6a38d38066c6bb00e651a66c2d7e64736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "verify(bytes,bytes32,bytes32,bytes32)": {
        "details": "This method additionally ensures that the input hash is all-zeros (i.e. no committed input), the exit code is (Halted, 0), and there are no assumptions (i.e. the receipt is unconditional).",
        "params": {
          "imageId": "The identifier for the guest program.",
          "journalDigest": "The SHA-256 digest of the journal bytes.",
          "postStateDigest": "A hash of the final memory state. Required to run the verifier, but     otherwise can be left unconstrained for most use cases.",
          "seal": "The encoded cryptographic proof (i.e. SNARK)."
        },
        "returns": {
          "_0": "true if the receipt passes the verification checks. The return code must be checked."
        }
      },
      "verify_integrity((bytes,(bytes32,bytes32,(uint8,uint8),bytes32,bytes32)))": {
        "params": {
          "receipt": "The receipt to be verified."
        },
        "returns": {
          "_0": "true if the receipt passes the verification checks. The return code must be checked."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "CONTROL_ID_0()": {
        "notice": "Control ID hash for the identity_p254 predicate decomposed by `splitDigest`."
      },
      "verify(bytes,bytes32,bytes32,bytes32)": {
        "notice": "Verify that the given seal is a valid RISC Zero proof of execution with the     given image ID, post-state digest, and journal digest."
      },
      "verify_integrity((bytes,(bytes32,bytes32,(uint8,uint8),bytes32,bytes32)))": {
        "notice": "Verify that the given receipt is a valid RISC Zero receipt, ensuring the `seal` is valid a cryptographic proof of the execution with the given `claim`."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}